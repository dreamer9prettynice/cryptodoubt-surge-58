#pragma version >=0.2.0;

;; Storage variables
;; bet_id: String
;; title: String
;; total_amount: Coins
;; yes_amount: Coins
;; no_amount: Coins
;; expiration_time: Integer
;; creator_address: Address
;; status: String (active/resolved)
;; participants: Dictionary<Address, Tuple<String, Coins>>

(slice, slice, int, int, int, int, slice, slice, cell) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_bits(), ;; bet_id
        ds~load_bits(), ;; title
        ds~load_coins(), ;; total_amount
        ds~load_coins(), ;; yes_amount
        ds~load_coins(), ;; no_amount
        ds~load_uint(64), ;; expiration_time
        ds~load_msg_addr(), ;; creator_address
        ds~load_bits(), ;; status
        ds~load_dict() ;; participants
    );
}

() save_data(slice bet_id, slice title, int total_amount, int yes_amount, 
            int no_amount, int expiration_time, slice creator_address, 
            slice status, cell participants) impure inline {
    set_data(begin_cell()
        .store_slice(bet_id)
        .store_slice(title)
        .store_coins(total_amount)
        .store_coins(yes_amount)
        .store_coins(no_amount)
        .store_uint(expiration_time, 64)
        .store_slice(creator_address)
        .store_slice(status)
        .store_dict(participants)
        .end_cell());
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; Deploy message
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; Ignore bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    
    if (op == 1) { ;; Place bet
        (slice bet_id, slice title, int total_amount, int yes_amount, 
         int no_amount, int expiration_time, slice creator_address, 
         slice status, cell participants) = load_data();

        throw_if(401, equal_slices(status, "resolved"));
        throw_if(402, now() >= expiration_time);

        slice choice = in_msg_body~load_bits();
        int amount = msg_value;
        
        ;; Update amounts based on choice
        if (equal_slices(choice, "yes")) {
            yes_amount += amount;
        } else {
            no_amount += amount;
        }
        total_amount += amount;

        ;; Store participant data
        participants~udict_set_builder(256, slice_hash(sender_address), begin_cell()
            .store_slice(choice)
            .store_coins(amount));

        save_data(bet_id, title, total_amount, yes_amount, no_amount,
                 expiration_time, creator_address, status, participants);
        return ();
    }

    if (op == 2) { ;; Resolve bet
        (slice bet_id, slice title, int total_amount, int yes_amount, 
         int no_amount, int expiration_time, slice creator_address, 
         slice status, cell participants) = load_data();

        throw_if(403, ~ equal_slices(sender_address, creator_address));
        throw_if(404, equal_slices(status, "resolved"));
        
        slice outcome = in_msg_body~load_bits();
        int winner_amount = equal_slices(outcome, "yes") ? yes_amount : no_amount;
        int loser_amount = equal_slices(outcome, "yes") ? no_amount : yes_amount;

        ;; Calculate rewards and send to winners
        int total_winning_share = muldiv(total_amount, 95, 100); ;; 5% fee
        cell winners = new_dict();
        int key = -1;
        do {
            (key, slice cs, int f) = participants.udict_get_next?(256, key);
            if (f) {
                slice participant_choice = cs~load_bits();
                int participant_amount = cs~load_coins();
                
                if (equal_slices(participant_choice, outcome)) {
                    int reward = muldiv(participant_amount, total_winning_share, winner_amount);
                    var msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(sender_address)
                        .store_coins(reward)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        .end_cell();
                    send_raw_message(msg, 1);
                }
            }
        } until (~ f);

        save_data(bet_id, title, total_amount, yes_amount, no_amount,
                 expiration_time, creator_address, "resolved", participants);
        return ();
    }

    if (op == 3) { ;; Join bet
        (slice bet_id, slice title, int total_amount, int yes_amount, 
         int no_amount, int expiration_time, slice creator_address, 
         slice status, cell participants) = load_data();

        throw_if(401, equal_slices(status, "resolved"));
        throw_if(402, now() >= expiration_time);

        slice choice = in_msg_body~load_bits();
        int amount = in_msg_body~load_coins();
        
        ;; Calculate and deduct fee
        int fee = muldiv(amount, 5, 100); ;; 5% fee
        int bet_amount = amount - fee;

        ;; Send fee to specified address
        slice fee_address = "UQAWtRkKE_A8SaUTl8h4WCGiz2H2DhgMfrxlP28mvsz8_zwp"a;
        var fee_msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(fee_address)
            .store_coins(fee)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op, 32)
            .store_slice(bet_id)
            .end_cell();
        send_raw_message(fee_msg, 1);

        ;; Update amounts based on choice
        if (equal_slices(choice, "yes")) {
            yes_amount += bet_amount;
        } else {
            no_amount += bet_amount;
        }
        total_amount += bet_amount;

        ;; Store participant data
        participants~udict_set_builder(256, slice_hash(sender_address), begin_cell()
            .store_slice(choice)
            .store_coins(bet_amount));

        save_data(bet_id, title, total_amount, yes_amount, no_amount,
                 expiration_time, creator_address, status, participants);
        return ();
    }

    throw(405); ;; Unknown operation
}

;; Get methods
(int, int, int, slice, int) get_status() method_id {
    (slice bet_id, slice title, int total_amount, int yes_amount, 
     int no_amount, int expiration_time, slice creator_address, 
     slice status, cell participants) = load_data();
    return (total_amount, yes_amount, no_amount, status, expiration_time);
}

cell get_participants() method_id {
    (slice bet_id, slice title, int total_amount, int yes_amount, 
     int no_amount, int expiration_time, slice creator_address, 
     slice status, cell participants) = load_data();
    return participants;
}